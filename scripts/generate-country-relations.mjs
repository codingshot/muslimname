#!/usr/bin/env node
/**
 * Generates src/data/countryRelations.ts from:
 * - iso-countries.json (region/subregion)
 * - mledoze countries (borders, alpha-3)
 */
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const root = path.resolve(__dirname, "..");

const isoPath = path.join(root, "iso-countries.json");
const outputPath = path.join(root, "src/data/countryRelations.ts");

// Fetch mledoze countries
const MLEDOZE_URL = "https://raw.githubusercontent.com/mledoze/countries/master/countries.json";

async function main() {
  const iso = JSON.parse(fs.readFileSync(isoPath, "utf8"));
  const a3to2 = Object.fromEntries(iso.map((c) => [c["alpha-3"], c["alpha-2"]]));

  const res = await fetch(MLEDOZE_URL);
  if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
  const mledoze = await res.json();

  // Build region map: alpha-2 -> { region, subRegion }
  const regions = {};
  for (const c of iso) {
    const a2 = c["alpha-2"];
    if (a2 && (c.region || c["sub-region"])) {
      regions[a2] = {
        region: c.region || "",
        subRegion: c["sub-region"] || "",
      };
    }
  }

  // Build borders: alpha-2 -> alpha-2[]
  const borders = {};
  for (const c of mledoze) {
    const a2 = c.cca2;
    if (!a2 || !Array.isArray(c.borders)) continue;
    const neighbors = c.borders
      .map((a3) => a3to2[a3])
      .filter(Boolean);
    if (neighbors.length > 0) {
      borders[a2] = neighbors;
    }
  }

  const ts = `/**
 * Country relations for related-countries algorithm.
 * Generated by scripts/generate-country-relations.mjs
 * - Regions from iso-countries.json
 * - Borders from mledoze/countries (alpha-2 codes)
 */

export interface CountryRegion {
  region: string;
  subRegion: string;
}

export const countryRegions: Record<string, CountryRegion> = ${JSON.stringify(regions, null, 2)};

export const countryBorders: Record<string, string[]> = ${JSON.stringify(borders, null, 2)};

/** Minimal shape for getRelatedCountries - matches LegalNameChangeGuide */
interface GuideForRelated {
  country: string;
  countryCode: string;
  flag: string;
  difficulty: string;
  estimatedCostUSD: [number, number];
}

/**
 * Get related countries for a guide using a similarity algorithm:
 * - Bordering countries (highest weight)
 * - Same region
 * - Same sub-region
 * - Same difficulty
 * - Similar cost range
 */
export function getRelatedCountries(
  guide: GuideForRelated,
  allGuides: GuideForRelated[],
  limit = 6
): GuideForRelated[] {
  const code = normalizeCode(guide.countryCode);
  const myRegion = countryRegions[code];
  const myBorders = new Set(countryBorders[code] || []);

  const scored = allGuides
    .filter((g) => normalizeCode(g.countryCode) !== code)
    .map((g) => {
      const c = normalizeCode(g.countryCode);
      let score = 0;

      if (myBorders.has(c)) score += 50;
      if (myRegion?.region && countryRegions[c]?.region === myRegion.region) score += 20;
      if (myRegion?.subRegion && countryRegions[c]?.subRegion === myRegion.subRegion) score += 30;
      if (g.difficulty === guide.difficulty) score += 10;

      const [a1, a2] = guide.estimatedCostUSD;
      const [b1, b2] = g.estimatedCostUSD;
      const overlap = Math.max(0, Math.min(a2, b2) - Math.max(a1, b1));
      if (overlap > 0 || (a1 <= b2 && b1 <= a2)) score += 5;

      return { guide: g, score };
    })
    .filter((x) => x.score > 0)
    .sort((a, b) => b.score - a.score);

  return scored.slice(0, limit).map((x) => x.guide);
}

function normalizeCode(code: string): string {
  return code.split("-")[0];
}
`;

  fs.writeFileSync(outputPath, ts);
  console.log(`Wrote ${outputPath}`);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
